# Project  - Cursor Rules

## 프로젝트 개요
이 프로젝트는 Spring Modulith 기반의 모듈형 아키텍처를 사용하는 차세대 WRMS 솔루션입니다.
Java 21, Spring Boot 3.5.7, Vaadin 24.9.4를 기반으로 하며, 도메인 중심 개발(DDD) 패턴을 따릅니다.

## 핵심 아키텍처 원칙

### 1. 모듈 구조
- 모든 모듈은 `com.wrms.newtype.{module-name}` 패키지에 위치
- 모듈명은 **소문자, 단수형**으로 작성 (예: `order`, `product`, `customer`)
- 각 모듈은 다음 구조를 따라야 함:
  ```
  {module}/
  ├── {Module}Module.java           # @Modulith 어노테이션 적용된 모듈 식별 인터페이스
  ├── api/                          # 공개 API (다른 모듈에서 접근 가능)
  │   ├── domain/                   # 도메인 값 타입 (Enum 등)
  │   ├── dto/
  │   │   ├── request/              # 요청 DTO
  │   │   └── response/             # 응답 DTO
  │   ├── event/                    # 이벤트 클래스
  │   ├── exception/                # 모듈별 예외 (BusinessException 상속)
  │   └── service/                  # 서비스 인터페이스
  │       ├── {Module}CommandService.java
  │       └── {Module}QueryService.java
  └── internal/                     # 내부 구현 (다른 모듈에서 접근 불가)
      ├── application/
      │   └── service/              # 서비스 구현체
      │       └── {Module}ServiceImpl.java
      ├── domain/                   # 도메인 엔티티
      └── infrastructure/
          ├── config/               # 모듈 설정
          └── persistence/          # Repository 인터페이스 및 구현
  ```

### 2. 개발 순서
모듈 개발 시 다음 순서를 반드시 준수:
1. `internal.domain` - 도메인 엔티티 및 비즈니스 로직
2. `resources/db/migration` - 도메인 DDL 생성
   - 파일명: `V{n}__create_{module}_tables.sql` (예: `V7__create_order_tables.sql`)
   - 도메인 엔티티에 맞춰 테이블 스키마 작성
   - 인덱스 및 외래키 제약조건 포함
3. `resources/data.sql` - 샘플 데이터 추가
   - 개발/테스트용 샘플 데이터 INSERT 문 작성
   - 도메인 엔티티의 다양한 상태를 테스트할 수 있는 데이터 포함
4. `infrastructure.persistence` - 데이터 접근 계층
   - Repository 인터페이스 작성
   - Spring Data JDBC 메서드 네이밍 규칙 준수
5. `api` - 공개 인터페이스, DTO, 이벤트, 예외 정의
   - 서비스 인터페이스 (CommandService, QueryService)
   - Request/Response DTO
   - 도메인 이벤트 정의
   - 비즈니스 예외 클래스
6. `internal.application` - 애플리케이션 서비스 구현
   - 서비스 구현체 작성
   - 트랜잭션 관리 및 이벤트 발행
7. `ui/{module}` - Vaadin UI 구현
   - **Vaadin MCP를 사용하여 UI 컴포넌트 및 뷰 생성**
   - 리스트 뷰, 상세 뷰, 생성/수정 폼 구현
   - `@Route` 어노테이션으로 라우팅 설정
   - `MainLayout` 레이아웃 사용
8. `resources/data.sql` - 메뉴 데이터 추가 (UI 구현 완료 후)
   - 메뉴 그룹, 메뉴, 권한 데이터 INSERT
   - UI 라우트와 매핑되는 메뉴 정보 추가

### 3. 네이밍 규칙

#### 클래스명
- **모듈 인터페이스**: `{Module}Module` (예: `OrderModule`, `CustomerModule`)
- **서비스 인터페이스**: `{Module}CommandService`, `{Module}QueryService`
- **서비스 구현체**: `{Module}ServiceImpl` (단순 모듈) 또는 `{Module}CommandServiceImpl`, `{Module}QueryServiceImpl`
- **도메인 엔티티**: 파스칼 케이스 (예: `Order`, `Customer`, `OrderItem`)
- **DTO**: `{Action}{Entity}Request`, `{Entity}Response` (예: `CreateOrderRequest`, `OrderResponse`)
- **이벤트**: `{Entity}{Action}Event` (예: `OrderCreatedEvent`, `CustomerUpdatedEvent`)
- **예외**: `{Entity}NotFoundException`, `{Entity}ValidationException` 등
- **Repository**: `{Entity}Repository` (예: `OrderRepository`)

#### 패키지명
- 모든 패키지명은 **소문자**로 작성
- 단어 구분 없이 이어서 작성 (예: `api`, `internal`, `application`, `infrastructure`)

### 4. 도메인 엔티티 작성 규칙

```java
package com.wrms.newtype.{module}.internal.domain;

import com.wrms.newtype.shared.base.BaseEntity;
import lombok.Builder;
import lombok.Getter;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

@Getter
@Table("{table_name}")
public class {Entity} extends BaseEntity {
    
    @Id
    @Column("id")
    private Long id;
    
    @Column("field_name")
    private String fieldName;
    // 필드 정의...
    
    /**
     * 기본 생성자 (Spring Data JDBC가 객체를 생성할 때 필요)
     */
    {Entity}() {
        // Spring Data JDBC가 조회 시 객체를 생성하기 위해 필요
    }
    
    @Builder
    public {Entity}(/* 파라미터 */) {
        // 초기화 로직
        initializeTimestamps(); // BaseEntity 메서드 호출
    }
    
    // 비즈니스 메서드
    public void updateStatus(Status newStatus) {
        // 비즈니스 로직
        updateTimestamp(); // BaseEntity 메서드 호출
    }
    
    /**
     * ID 설정 (Repository에서 사용)
     */
    void setId(Long id) {
        this.id = id;
    }
    
    /**
     * 필드 설정 (Spring Data JDBC가 조회 시 사용)
     * package-private setter로 설정
     */
    void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
}
```

**중요 사항**:
- `BaseEntity`를 상속하여 `createdAt`, `updatedAt` 자동 관리
- 생성자에서 `initializeTimestamps()` 호출 필수
- 수정 메서드에서 `updateTimestamp()` 호출 필수
- Lombok `@Getter` 사용, `@Setter`는 사용하지 않음
- Spring Data JDBC 매핑을 위해 `@Table`, `@Column` 어노테이션 사용
- Spring Data JDBC가 조회 시 객체를 생성하기 위해 package-private setter 필요
- 기본 생성자 필수 (Spring Data JDBC용)
- 불변성을 최대한 유지 (public setter는 사용하지 않음)

### 5. Repository 작성 규칙

```java
package com.wrms.newtype.{module}.internal.infrastructure.persistence;

import com.wrms.newtype.{module}.internal.domain.{Entity};
import org.springframework.data.jdbc.repository.query.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;

public interface {Entity}Repository extends CrudRepository<{Entity}, Long> {
    
    @Query("SELECT * FROM {table} WHERE ...")
    Optional<{Entity}> findBy{Field}(@Param("field") String field);
}
```

**중요 사항**:
- `CrudRepository` 또는 `PagingAndSortingRepository` 상속
- Spring Data JDBC 사용 (JPA 아님)
- 커스텀 쿼리는 `@Query` 어노테이션 사용
- 메서드명은 Spring Data 메서드 네이밍 규칙 준수

### 6. 서비스 인터페이스 작성 규칙

```java
package com.wrms.newtype.{module}.api.service;

public interface {Module}CommandService {
    {Entity}Response create(Create{Entity}Request request);
    void update(Long id, Update{Entity}Request request);
    void delete(Long id);
}

public interface {Module}QueryService {
    {Entity}Response findById(Long id);
    List<{Entity}Response> findAll(SearchRequest request);
}
```

**중요 사항**:
- Command와 Query 분리 (CQRS 패턴)
- 인터페이스는 `api.service` 패키지에 위치
- DTO만 사용 (도메인 엔티티 직접 반환 금지)

### 7. 서비스 구현체 작성 규칙

**패턴 선택:**
- **단순 모듈**: 단일 구현체가 Command와 Query 모두 구현 (권장)
- **복잡한 모듈**: Command와 Query 구현체 분리

#### 패턴 1: 단일 구현체 (단순 모듈)

```java
package com.wrms.newtype.{module}.internal.application.service;

import com.wrms.newtype.{module}.api.service.{Module}CommandService;
import com.wrms.newtype.{module}.api.service.{Module}QueryService;
import com.wrms.newtype.{module}.api.dto.request.Create{Entity}Request;
import com.wrms.newtype.{module}.api.dto.response.{Entity}Response;
import com.wrms.newtype.{module}.internal.domain.{Entity};
import com.wrms.newtype.{module}.internal.infrastructure.persistence.{Entity}Repository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Transactional
public class {Module}ServiceImpl implements {Module}CommandService, {Module}QueryService {
    
    private final {Entity}Repository repository;
    private final ApplicationEventPublisher eventPublisher;
    
    @Override
    public {Entity}Response create(Create{Entity}Request request) {
        {Entity} entity = {Entity}.builder()
            // 빌더 패턴으로 엔티티 생성
            .build();
        
        {Entity} saved = repository.save(entity);
        
        // 이벤트 발행
        eventPublisher.publishEvent(new {Entity}CreatedEvent(saved.getId()));
        
        return {Entity}Response.from(saved);
    }
    
    @Override
    @Transactional(readOnly = true)
    public {Entity}Response findById(Long id) {
        {Entity} entity = repository.findById(id)
            .orElseThrow(() -> new {Entity}NotFoundException(id));
        return {Entity}Response.from(entity);
    }
}
```

#### 패턴 2: 분리된 구현체 (복잡한 모듈)

```java
// CommandServiceImpl
@Service
@RequiredArgsConstructor
@Transactional
public class {Module}CommandServiceImpl implements {Module}CommandService {
    // Command 관련 메서드만 구현
}

// QueryServiceImpl
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class {Module}QueryServiceImpl implements {Module}QueryService {
    // Query 관련 메서드만 구현
}
```

**중요 사항**:
- `@Service` 어노테이션 필수
- `@RequiredArgsConstructor`로 의존성 주입
- `@Transactional` 어노테이션으로 트랜잭션 관리
- 읽기 전용 쿼리는 `@Transactional(readOnly = true)` 사용
- 이벤트는 `ApplicationEventPublisher`로 발행
- 도메인 엔티티를 DTO로 변환하여 반환 (`{Entity}Response.from()` 사용)

### 8. DTO 작성 규칙

#### Request DTO
```java
package com.wrms.newtype.{module}.api.dto.request;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

public record Create{Entity}Request(
    @NotNull
    @Size(min = 1, max = 100)
    String name,
    
    String description
) {}
```

#### Response DTO
```java
package com.wrms.newtype.{module}.api.dto.response;

import java.time.LocalDateTime;

public record {Entity}Response(
    Long id,
    String name,
    String description,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    /**
     * 도메인 엔티티로부터 Response DTO를 생성합니다.
     * 
     * 주의: Spring Modulith 규칙상 api 패키지에서 internal 패키지를 직접 참조할 수 없으므로,
     * 이 메서드는 서비스 구현체(internal.application)에서만 사용됩니다.
     * 
     * @param entity 도메인 엔티티
     * @return Response DTO
     */
    public static {Entity}Response from(com.wrms.newtype.{module}.internal.domain.{Entity} entity) {
        return new {Entity}Response(
            entity.getId(),
            entity.getName(),
            entity.getDescription(),
            entity.getCreatedAt(),
            entity.getUpdatedAt()
        );
    }
}
```

**중요 사항**:
- Java Record 클래스 사용 권장
- Validation 어노테이션 사용 (`@NotNull`, `@Size` 등)
- Response DTO는 `from()` 정적 팩토리 메서드 제공
  - **주의**: Spring Modulith 규칙상 `api`에서 `internal`을 직접 import하면 안 되므로, FQCN(Full Qualified Class Name) 사용
  - 또는 서비스 구현체에서 private 변환 메서드 사용 가능 (선택)
- 도메인 엔티티의 내부 구조를 숨김

### 9. 이벤트 작성 규칙

```java
package com.wrms.newtype.{module}.api.event;

/**
 * {Entity} 생성 이벤트
 * 다른 모듈에서 이 이벤트를 구독하여 후속 작업을 수행할 수 있습니다.
 */
public record {Entity}CreatedEvent(
    Long {entity}Id,
    String additionalInfo
) {}
```

**중요 사항**:
- Record 클래스 사용 권장
- 이벤트명은 `{Entity}{Action}Event` 형식 (예: `OrderCreatedEvent`, `CustomerUpdatedEvent`)
- 이벤트는 `api.event` 패키지에 위치
- 이벤트는 모듈 간 통신을 위한 도메인 이벤트로 사용
- 이벤트 발행은 `ApplicationEventPublisher.publishEvent()` 사용
- Spring Modulith에서는 별도의 `@DomainEvent` 어노테이션이 필요하지 않음 (Spring Modulith 1.4.4 기준)

### 10. 예외 처리 규칙

```java
package com.wrms.newtype.{module}.api.exception;

import com.wrms.newtype.shared.common.exception.BusinessException;
import com.wrms.newtype.shared.common.constant.ErrorCode;

public class {Entity}NotFoundException extends BusinessException {
    
    public {Entity}NotFoundException(Long id) {
        super(
            ErrorCode.{ENTITY}_NOT_FOUND,
            String.format("{Entity} not found with id: %d", id)
        );
    }
}
```

**중요 사항**:
- 모든 예외는 `BusinessException` 상속
- `ErrorCode` enum 사용
- 예외는 `api.exception` 패키지에 위치

### 11. ID 생성 규칙

- NanoID 사용: `NanoIdUtil.generate()` 또는 `NanoIdUtil.generateCustomerId()` 등
- Long 타입 사용 시: 데이터베이스 자동 생성 또는 시퀀스 사용
- UUID는 사용하지 않음

### 11-1. 데이터베이스 마이그레이션 파일 작성 규칙

```sql
-- 파일명: V{n}__create_{module}_tables.sql
-- 예: V7__create_order_tables.sql

-- 주문 테이블 생성
CREATE TABLE orders (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    customer_id BIGINT NOT NULL,
    order_status VARCHAR(50) NOT NULL,
    total_amount DECIMAL(19, 2) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL
);

-- 인덱스 생성
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(order_status);
```

**중요 사항**:
- 파일명은 Flyway 형식: `V{순번}__create_{module}_tables.sql`
- 순번은 기존 마이그레이션 파일의 최대값 + 1
- 테이블명은 복수형 (예: `orders`, `customers`, `products`)
- `created_at`, `updated_at` 컬럼 필수 포함
- 인덱스는 외래키 및 자주 조회되는 컬럼에 생성
- 외래키 제약조건 명시 (ON DELETE CASCADE 등)

### 11-2. data.sql 샘플 데이터 작성 규칙

```sql
-- data.sql 파일에 추가

-- 주문 샘플 데이터
INSERT INTO orders (id, customer_id, order_status, total_amount, created_at, updated_at)
VALUES 
    (1, 1, 'PENDING', 10000.00, '2024-01-01 10:00:00', '2024-01-01 10:00:00'),
    (2, 1, 'COMPLETED', 25000.50, '2024-01-02 14:30:00', '2024-01-02 15:00:00'),
    (3, 2, 'CANCELLED', 5000.00, '2024-01-03 09:15:00', '2024-01-03 09:20:00');
```

**중요 사항**:
- 도메인 엔티티의 다양한 상태를 테스트할 수 있는 샘플 데이터 포함
- 개발 및 테스트 목적으로 사용
- ID는 자동 증가이므로 생략 가능 (명시하는 경우 고유값 사용)
- `created_at`, `updated_at` 값 명시

### 11-3. data.sql 메뉴 데이터 작성 규칙 (UI 구현 완료 후)

```sql
-- data.sql 파일에 메뉴 섹션에 추가

-- 메뉴 그룹 (필요시)
INSERT INTO menu_groups (group_code, group_name, display_order, icon, is_active, description)
VALUES ('order', 'Order', 2, 'SHOPPING_CART', TRUE, '주문 관리');

-- 메뉴
INSERT INTO menus (group_id, menu_code, menu_name, route_path, view_class_name, action_type, display_order, icon, is_active)
VALUES 
    ((SELECT group_id FROM menu_groups WHERE group_code = 'order'),
     'order-list', '주문 목록', 'order-list', 
     'com.wrms.newtype.ui.order.OrderListView', 'READ', 1, 'LIST', TRUE),
    ((SELECT group_id FROM menu_groups WHERE group_code = 'order'),
     'order-detail', '주문 상세', 'order-detail/:orderId', 
     'com.wrms.newtype.ui.order.OrderDetailView', 'READ', 2, 'FILE', TRUE),
    ((SELECT group_id FROM menu_groups WHERE group_code = 'order'),
     'order-create', '주문 생성', 'order-create', 
     'com.wrms.newtype.ui.order.OrderCreateView', 'CREATE', 3, 'PLUS', TRUE);

-- 권한 (필요시)
INSERT INTO permissions (permission_code, permission_name, menu_code, action_type, description)
VALUES 
    ('order:read', '주문 조회', 'order', 'READ', '주문 목록 및 상세 조회 권한'),
    ('order:create', '주문 생성', 'order', 'CREATE', '주문 등록 권한'),
    ('order:update', '주문 수정', 'order', 'UPDATE', '주문 정보 수정 권한'),
    ('order:delete', '주문 삭제', 'order', 'DELETE', '주문 삭제 권한');
```

**중요 사항**:
- UI 구현이 완료된 후에만 메뉴 데이터 추가
- `route_path` 값은 `@Route` 어노테이션의 `value`와 일치해야 함
- `menu_code`는 고유해야 하며, 일반적으로 `{module}-list`, `{module}-detail` 형식 사용
- `view_class_name`은 View 클래스의 전체 경로 (FQCN)
- `action_type`은 권한 관리용 (READ, CREATE, UPDATE, DELETE)
- 메뉴 그룹의 `group_code`는 고유해야 함
- 권한의 `permission_code`는 `{module}:{action}` 형식 사용 (예: `order:read`)
- 메뉴 그룹, 메뉴, 권한의 ID는 자동 증가이므로 명시하지 않음

### 12. Vaadin UI 작성 규칙

**UI 개발 시 Vaadin MCP 사용 필수**:
- Vaadin MCP(Model Context Protocol)를 활용하여 UI 컴포넌트 및 뷰 생성
- Vaadin 공식 문서 및 컴포넌트 API를 참조하여 최신 컴포넌트 사용
- React 컴포넌트 통합이 필요한 경우 Vaadin React Components 활용

```java
package com.wrms.newtype.ui.{module};

import com.vaadin.flow.component.button.Button;
import com.vaadin.flow.component.grid.Grid;
import com.vaadin.flow.component.orderedlayout.VerticalLayout;
import com.vaadin.flow.router.PageTitle;
import com.vaadin.flow.router.Route;
import com.wrms.newtype.ui.layout.MainLayout;

@Route(value = "{module}-list", layout = MainLayout.class)
@PageTitle("{Module} List")
public class {Entity}ListView extends VerticalLayout {
    
    private final {Module}QueryService queryService;
    
    public {Entity}ListView({Module}QueryService queryService) {
        this.queryService = queryService;
        
        Grid<{Entity}Response> grid = new Grid<>();
        grid.addColumn({Entity}Response::getId).setHeader("ID");
        // ... 그리드 설정
        
        add(grid);
    }
}

// 상세 뷰 예시
@Route(value = "{module}-detail/:{entity}Id", layout = MainLayout.class)
@PageTitle("{Module} Detail")
public class {Entity}DetailView extends VerticalLayout {
    // ...
}

// 생성 뷰 예시
@Route(value = "{module}-create", layout = MainLayout.class)
@PageTitle("Create {Module}")
public class {Entity}CreateView extends VerticalLayout {
    // ...
}
```

**중요 사항**:
- **Vaadin MCP를 사용하여 UI 컴포넌트 및 뷰 생성**
- `@Route` 어노테이션으로 라우팅 설정
  - 목록 뷰: `"{module}-list"` (예: `"order-list"`, `"customer-list"`)
  - 상세 뷰: `"{module}-detail/:{entity}Id"` (예: `"order-detail/:orderId"`)
  - 생성 뷰: `"{module}-create"` (예: `"order-create"`)
- `MainLayout` 레이아웃 사용
- `@PageTitle` 어노테이션으로 페이지 제목 설정
- 생성자 주입 사용
- UI 구현 완료 후 `data.sql`에 메뉴 데이터 추가 필수

### 13. 코드 생성 시 주의사항

1. **모듈 간 의존성**:
   - 다른 모듈의 `api` 패키지만 접근 가능
   - 다른 모듈의 `internal` 패키지는 절대 접근 불가
   - `shared` 패키지는 모든 모듈에서 접근 가능

2. **패키지 접근 규칙**:
   - `api` → 다른 모듈의 `api` (허용)
   - `api` → `shared` (허용)
   - `internal` → `api` (금지, 순환 참조)
   - `internal` → `shared` (허용)

3. **이벤트 기반 통신**:
   - 모듈 간 통신은 이벤트 사용 권장
   - 직접적인 서비스 호출은 최소화

4. **트랜잭션 관리**:
   - 서비스 메서드에 `@Transactional` 적용
   - 읽기 전용 쿼리는 `@Transactional(readOnly = true)` 사용

5. **문서화**:
   - 모든 public 클래스와 메서드에 JavaDoc 작성
   - 복잡한 비즈니스 로직은 주석으로 설명

### 14. 금지 사항

- ❌ 다른 모듈의 `internal` 패키지 직접 접근
- ❌ 도메인 엔티티를 API 레이어에서 직접 반환
- ❌ `@Setter` 사용 (불변성 유지)
- ❌ UUID 사용 (NanoID 사용)
- ❌ JPA 사용 (Spring Data JDBC 사용)
- ❌ 순환 의존성 발생시키는 코드
- ❌ `shared` 패키지에서 비즈니스 모듈 import

### 15. 파일 생성 시 체크리스트

새 모듈 생성 시:
- [ ] `{Module}Module.java` 생성 및 `@Modulith` 적용
- [ ] `internal.domain` 패키지에 도메인 엔티티 작성
- [ ] `resources/db/migration/V{n}__create_{module}_tables.sql` 파일 생성 및 DDL 작성
- [ ] `resources/data.sql`에 샘플 데이터 추가
- [ ] `internal.infrastructure.persistence` 패키지에 Repository 작성
- [ ] `api.service` 패키지에 서비스 인터페이스 작성
- [ ] `api.dto` 패키지에 Request/Response DTO 작성
- [ ] `api.exception` 패키지에 예외 클래스 작성 (필요시)
- [ ] `api.event` 패키지에 이벤트 클래스 작성 (필요시)
- [ ] `internal.application.service` 패키지에 서비스 구현체 작성
- [ ] `ui/{module}` 패키지에 Vaadin UI 뷰 작성 (Vaadin MCP 사용)
- [ ] `resources/data.sql`에 메뉴 데이터 추가 (UI 구현 완료 후)
- [ ] Spring Modulith 검증 통과 확인

## 참고 문서

프로젝트의 상세한 가이드는 `docs/` 폴더 참조:
- `ARCHITECTURE.md`: 전체 아키텍처 설계
- `MODULE_DEVELOPMENT_GUIDE.md`: 모듈 개발 상세 가이드
- `EVENT_HANDLER_GUIDE.md`: 이벤트 핸들러 가이드
- `MENU_PERMISSION_SYSTEM_DESIGN.md`: 메뉴/권한 시스템 설계

## AI 코드 생성 시 요청

코드를 생성할 때는 다음을 명시적으로 요청:
1. 모듈명과 엔티티명을 명확히 지정
2. 필요한 패키지 구조를 명시
3. 기존 패턴과 일관성 유지
4. Spring Modulith 규칙 준수 확인
5. 테스트 코드 작성 여부 확인

